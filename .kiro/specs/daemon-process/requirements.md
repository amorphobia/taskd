# TaskD 守护进程需求规格

## 概述

实现一个无进程间通信的守护进程机制，用于管理 taskd 的后台任务监控和自动重启功能。守护进程本身作为一个内置任务运行，负责监控其他任务的状态并执行自动重启逻辑。

**核心改进**：
- 替换现有的 `onTaskExit` 回调机制为守护进程机制
- 解决命令进程退出时 goroutine 被销毁导致状态更新失效的问题
- 实现真正的后台任务状态监控和自动重启功能

## 用户故事

### 作为系统管理员
- 我希望能够启动一个守护进程来监控所有任务，这样即使命令进程退出，任务状态仍能得到正确维护
- 我希望守护进程能够自动重启失败的任务，减少手动干预的需要
- 我希望能够像管理普通任务一样管理守护进程（启动、停止、查看状态）

### 作为开发者
- 我希望守护进程机制能够替代现有的回调机制，解决进程退出时状态更新失效的问题
- 我希望系统能够自动启动守护进程，无需手动管理
- 我希望能够配置任务的自动重启策略，包括最大重试次数

## 功能需求

### 1. 内置守护任务

#### 1.1 守护任务定义
- **任务名称**: `taskd`（保留名称，用户不能创建同名任务）
- **任务类型**: 内置任务，不需要在 `.taskd/tasks/` 目录中创建配置文件
- **配置位置**: 相关配置存储在 `.taskd/config.toml` 中
- **等效配置**:
  ```toml
  display_name = "taskd"
  description = "The daemon task of taskd"
  executable = "/os/absolute/path/to/current/taskd.exe --daemon"
  workdir = "same/as/$TASKD_HOME"
  inherit_env = true
  ```

#### 1.2 守护任务操作限制
**允许的操作**:
- `taskd start taskd` - 启动守护进程
- `taskd stop taskd` - 停止守护进程  
- `taskd restart taskd` - 重启守护进程
- `taskd info taskd` - 获取守护进程信息

**禁止的操作**:
- `taskd add taskd` - 返回错误：任务名称冲突
- `taskd edit taskd` - 返回错误：不能编辑内置任务
- `taskd del taskd` - 返回错误：不能删除内置任务
- 用户手动创建的 `$TASKD_HOME/tasks/taskd.toml` 文件将被忽略

### 2. 守护进程启动机制

#### 2.1 进程分离设计
- **命令进程**: 用户执行的一次性 taskd 命令进程
- **守护进程**: 后台运行的 taskd 守护进程，使用 `taskd --daemon` 启动
- 启动守护进程时，命令进程启动一个新的 `taskd --daemon` 进程，而非自身留存后台

#### 2.2 --daemon 参数限制
- `--daemon` 参数仅供内部使用，不应由用户直接执行
- 如果用户使用其他参数时携带 `--daemon` 参数，应返回错误
- 理想情况下，用户直接使用 `taskd` 命令时不能携带该参数

#### 2.3 守护进程状态检查
启动守护进程前，命令进程需要检查 `runtime.json` 中的 taskd 任务状态：

**可以启动新守护进程的情况**:
- runtime.json 中不存在 taskd 任务记录
- 存在记录但 PID 对应的可执行文件无法获知（进程不存在或权限不足）
- 存在记录但 PID 对应的可执行文件不是 taskd（PID被其他进程重用）

**不启动新守护进程的情况**:
- 存在 taskd 任务记录，且 PID 对应的可执行文件确认是 taskd

#### 2.4 自动守护进程启动机制

**现有问题**:
- 当前实现使用 `onTaskExit` 回调函数异步更新 `runtime.json`
- 命令进程退出时会销毁所有 goroutine，导致回调机制失效
- 任务退出后的状态更新无法及时生效

**新机制**:
- 替换回调函数机制为守护进程机制
- 任何需要任务状态监控的操作都应确保守护进程运行
- 如果守护进程不存在，系统自动启动守护进程

**自动启动守护进程的时机**:
1. 执行任务管理命令时（start, stop, restart, list, info）
2. 启动任何具有 `auto_start=true` 的任务时
3. 系统检测到需要状态监控但守护进程不存在时

**守护进程职责**:
- 定时检查 `runtime.json` 中的任务状态并更新
- 监控运行中任务的进程状态，及时更新退出信息
- 对于自动启动任务，如果已停止且符合重启条件，执行自动重启
- 替代原有的 `onTaskExit` 回调机制

#### 2.5 运行时状态管理
- 守护进程的启动和停止由**命令进程**负责更新 `runtime.json`
- 守护进程启动后应无限期运行，直到被显式停止或进程被杀死

### 3. 自动重启功能

#### 3.1 配置扩展
在现有任务配置基础上添加以下字段：

**任务配置文件 (`<task>.toml`) 新增字段**:
```toml
auto_start = true           # 现有字段，标识是否为自动启动任务
max_retry_num = 3          # 新增：最大重试次数，默认值为3，0或负数表示无限重试
```

**运行时状态 (`runtime.json`) 新增字段**:
```json
{
  "tasks": {
    "task_name": {
      "name": "task_name",
      "status": "stopped",
      "pid": 0,
      "start_time": "2024-01-01T00:00:00Z",
      "end_time": "2024-01-01T00:01:00Z",
      "exit_code": 1,
      "stopped_by_taskd": false,    // 新增：是否由 taskd stop 命令停止
      "retry_num": 2                // 新增：当前重试次数
    }
  }
}
```

#### 3.2 重试逻辑
- `stopped_by_taskd` 字段：
  - 使用 `taskd stop <task>` 停止时，由命令进程设置为 `true`
  - 其他情况（任务自然退出、崩溃等）更新时，设置为 `false`
- `retry_num` 字段：
  - 记录当前重试次数
  - 使用 `taskd start <task>` 或 `taskd restart <task>` 启动时重置为 0
- 重试条件：
  - 任务配置中 `auto_start = true`
  - 任务状态为已停止
  - `stopped_by_taskd = false`（非用户主动停止）
  - `retry_num < max_retry_num`（未达到重试上限）

#### 3.3 守护进程监控职责
- 定时检查 `runtime.json` 中所有任务的状态
- 对符合重试条件的自动启动任务执行重启操作
- 重启成功后递增 `retry_num` 计数
- 使用合理的检查间隔，避免过度消耗 CPU 资源

### 4. 进程生命周期管理

#### 4.1 守护进程启动流程

**显式启动**:
1. 用户执行 `taskd start taskd`
2. 命令进程检查现有守护进程状态
3. 如果需要启动新守护进程：
   - 启动 `taskd --daemon` 进程
   - 更新 `runtime.json` 中的 taskd 任务信息
4. 命令进程退出

**自动启动**:
1. 用户执行任何任务管理命令（`start`, `stop`, `restart`, `list`, `info`）
2. 命令进程检查是否存在有效的守护进程
3. 如果守护进程不存在且需要状态监控：
   - 自动启动 `taskd --daemon` 进程
   - 更新 `runtime.json` 中的 taskd 任务信息
4. 继续执行原始命令
5. 命令进程退出，守护进程继续运行

#### 4.2 守护进程停止流程
1. 用户执行 `taskd stop taskd`
2. 命令进程终止守护进程
3. 更新 `runtime.json` 中的 taskd 任务状态
4. 命令进程退出

#### 4.3 守护进程重启流程
1. 用户执行 `taskd restart taskd`
2. 命令进程停止现有守护进程（如果存在）
3. 启动新的守护进程
4. 更新 `runtime.json`
5. 命令进程退出

## 验收标准

### AC1: 内置任务管理
- [ ] 1.1 守护任务名称 `taskd` 被系统保留，用户无法创建同名任务
- [ ] 1.2 `taskd add taskd` 命令返回错误提示任务名称冲突
- [ ] 1.3 `taskd edit taskd` 命令返回错误提示不能编辑内置任务
- [ ] 1.4 `taskd del taskd` 命令返回错误提示不能删除内置任务
- [ ] 1.5 用户创建的 `$TASKD_HOME/tasks/taskd.toml` 文件被系统忽略

### AC2: 守护进程操作
- [ ] 2.1 `taskd start taskd` 能够成功启动守护进程
- [ ] 2.2 `taskd stop taskd` 能够成功停止守护进程
- [ ] 2.3 `taskd restart taskd` 能够成功重启守护进程
- [ ] 2.4 `taskd info taskd` 能够显示守护进程的状态信息

### AC3: 进程分离机制
- [ ] 3.1 启动守护进程时，命令进程启动 `taskd --daemon` 后台进程而非自身留存
- [ ] 3.2 守护进程使用 `--daemon` 参数启动，工作目录为 `$TASKD_HOME`
- [ ] 3.3 用户不能直接使用 `taskd --daemon` 命令
- [ ] 3.4 用户使用其他参数时携带 `--daemon` 参数会返回错误

### AC4: 守护进程状态检查
- [ ] 4.1 启动前检查 `runtime.json` 中是否存在有效的守护进程
- [ ] 4.2 如果现有守护进程的 PID 无对应进程，可以启动新守护进程
- [ ] 4.3 如果现有守护进程的 PID 对应非 taskd 进程，可以启动新守护进程
- [ ] 4.4 如果现有守护进程仍在运行，不启动新的守护进程

### AC5: 自动守护进程启动机制
- [ ] 5.1 执行任务管理命令时，如果守护进程不存在，系统自动启动守护进程
- [ ] 5.2 启动 `auto_start=true` 的任务时，确保守护进程运行
- [ ] 5.3 守护进程替代原有的 `onTaskExit` 回调机制
- [ ] 5.4 守护进程能够监控运行中任务的进程状态并及时更新退出信息
- [ ] 5.5 命令进程退出后，守护进程继续运行并维护任务状态

### AC6: 运行时状态管理
- [ ] 6.1 守护进程启动时，命令进程更新 `runtime.json` 中的 taskd 任务信息
- [ ] 6.2 守护进程停止时，命令进程更新 `runtime.json` 中的 taskd 任务状态
- [ ] 6.3 守护进程启动后持续运行，直到被显式停止

### AC7: 配置扩展
- [ ] 7.1 任务配置支持 `max_retry_num` 字段，默认值为 3
- [ ] 7.2 `max_retry_num` 为 0 或负数时表示无限重试
- [ ] 7.3 `runtime.json` 中添加 `stopped_by_taskd` 布尔字段
- [ ] 7.4 `runtime.json` 中添加 `retry_num` 整数字段

### AC8: 自动重启逻辑
- [ ] 8.1 使用 `taskd stop <task>` 停止任务时，`stopped_by_taskd` 设置为 `true`
- [ ] 8.2 任务自然退出或崩溃时，`stopped_by_taskd` 设置为 `false`
- [ ] 8.3 使用 `taskd start <task>` 或 `taskd restart <task>` 时，`retry_num` 重置为 0
- [ ] 8.4 守护进程能够识别需要自动重启的任务（`auto_start=true`, `stopped_by_taskd=false`, 未达重试上限）

### AC9: 守护进程监控功能
- [ ] 9.1 守护进程定时检查所有任务状态
- [ ] 9.2 对符合条件的自动启动任务执行重启操作
- [ ] 9.3 重启成功后递增 `retry_num` 计数
- [ ] 9.4 达到 `max_retry_num` 上限后停止重试
- [ ] 9.5 守护进程使用合理的检查间隔，不过度消耗 CPU

### AC10: 错误处理
- [ ] 10.1 守护进程启动失败时返回明确的错误信息
- [ ] 10.2 守护进程停止失败时返回明确的错误信息
- [ ] 10.3 无效的 `--daemon` 参数使用返回错误信息
- [ ] 10.4 自动重启失败时记录错误信息但不影响其他任务监控

## 技术约束

1. **无进程间通信**: 守护进程和命令进程之间不使用任何形式的 IPC（管道、套接字、共享内存等）
2. **状态持久化**: 所有状态信息通过 `runtime.json` 文件进行持久化和共享
3. **平台兼容性**: 支持 Windows 平台的进程管理和 PID 检查
4. **资源效率**: 守护进程监控间隔应合理，避免过度的 CPU 和 I/O 消耗
5. **向后兼容**: 现有任务配置和运行时状态格式保持兼容，仅添加新字段

## 非功能需求

1. **可靠性**: 守护进程应能稳定运行，处理各种异常情况
2. **性能**: 监控检查不应显著影响系统性能
3. **可维护性**: 代码结构清晰，便于后续扩展和维护
4. **用户体验**: 命令响应迅速，错误信息清晰明确